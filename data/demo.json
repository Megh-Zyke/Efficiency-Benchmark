{
  "Solution_0": "class Solution:\n    def jump(self, nums: List[int]) -> int:\n        step = 0\n        curEnd = 0\n        fastest = 0\n        for i in range(len(nums) - 1):\n            fastest =  fastest if fastest > i + nums[i] else  i + nums[i]\n            if i == curEnd:\n                step += 1\n                curEnd = fastest\n        return step",
  "Solution_1": "class Solution:\n    def candy(self, ratings: List[int]) -> int:\n    \n        n = len(ratings)\n        candies = [1] * n \n\n        for i in range(1, n):\n            if ratings[i] > ratings[i-1]:\n                candies[i] = candies[i-1] + 1\n\n        for i in range(n-2, -1, -1):\n            if ratings[i] > ratings[i+1]:\n                candies[i] = max(candies[i], candies[i+1] + 1)\n        \n        return sum(candies)",
  "Solution_2": "class Solution:\n    def canCompleteCircuit(self, gas: List[int], cost: List[int]) -> int:\n        n = len(gas)\n        if sum(gas) - sum(cost) < 0:\n            return -1\n\n        curGas = 0\n        start = 0\n        for i in range(n):\n            curGas += gas[i] - cost[i]\n            if curGas < 0:\n                start = i + 1\n                curGas = 0\n        return start\n    ",
  "Solution_3": "class Solution:\n    def reconstructQueue(self, people: List[List[int]]) -> List[List[int]]:\n        res = []\n        people.sort(key = lambda x: (-x[0],x[1]))\n        for i, j in people:\n            res.insert(j,[i,j])\n        return res",
  "Solution_4": "class Solution:\n    def lengthOfLIS(self, nums: List[int]) -> int:\n        if len(nums) == 1:\n            return 1\n\n        piles = [[nums[0]]]\n\n        for i in range(1, len(nums)):\n            abs = False\n            for pile in piles:\n                if nums[i] <= pile[-1]:\n                    pile.append(nums[i])\n                    abs = True\n                    break\n            if not abs:\n                piles.append([nums[i]])\n    \n        return len(piles)\n            ",
  "Solution_5": "class Solution:\n    def wordBreak(self, s: str, wordDict: List[str]) -> bool:\n        wordDict = set(wordDict)\n        def solve(i, j, ans_till_now = set()):\n            # print(i, j, s[i:j+1],ans_till_now)\n            if (j-i) == 0:\n                return (True, ans_till_now)\n            for k in range(j, i-1, -1):\n                # print(i, k, j, s[i:k], s[i:k] in wordDict)\n                if not s[i:k] in wordDict:\n                    continue\n                ans, new_ans_set = solve(k,j, ans_till_now = ans_till_now.union(set([s[i:k]])))\n                ans, new_ans_set = solve(k,j)\n                if ans:\n                    return (True, new_ans_set)\n            return (False, ans_till_now)\n        \n        def bfs_solve():\n            q = deque([0])\n            seen = set()\n\n            while q:\n                start = q.popleft()\n                if start == len(s):\n                    return True\n                for end in range(start+1, len(s)+1):\n                    if end not in seen and s[start:end] in wordDict:\n                        q.append(end)\n                        seen.add(end)\n            return False\n\n        # out = solve(0, len(s), ans_till_now=set())\n        # print(out)\n        # return out[0]\n        return bfs_solve()",
  "Solution_6": "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        dp=[float('inf')]*(amount+1) # create list of amount+1 size and initialize with infinity\n        dp[0]=0 #base case 0 coin needed for 0 amount\n        for i in range(1,amount+1):# amount 1 to given tk\n            for coin in coins:\n                if i>=coin:\n                    dp[i]=min(dp[i],1+dp[i-coin])\n        if dp[amount]!=float('inf'):\n            return dp[amount]\n        else:\n            return -1",
  "Solution_7": "class Solution:\n    def minDistance(self, word1: str, word2: str) -> int:\n        cache = [[float(\"inf\")] * (len(word2) + 1) for i in range(len(word1) + 1)]\n        \n        for j in range(len(word2) + 1):\n            cache[len(word1)][j] = len(word2) - j\n        for i in range(len(word1) + 1):\n            cache[i][len(word2)] = len(word1) - i\n\n        for i in range(len(word1) -1, -1, -1):\n            for j in range(len(word2) -1, -1, -1):\n                if word1[i] == word2[j]:\n                    cache[i][j] = cache[i + 1][j + 1]\n                else:\n                    cache[i][j] = 1 + min(cache[i + 1][j], cache[i][j + 1], cache[i+1][j+1])\n        \n        return cache[0][0]",
  "Solution_8": "class Solution:\n    def exist(self, board: List[List[str]], word: str) -> bool:\n        def _dfs(self, board: List[List[str]], visited:List[List[bool]], word:str, m:int, n:int, pos:int) -> bool:\n            if m<0 or m >= len(board) or n < 0 or n >= len(board[0]) or word[pos] != board[m][n] or visited[m][n]:\n                return False\n            if pos == len(word) - 1:\n                return True\n            visited[m][n] = True\n            for move in [(0,1),(1,0),(0,-1),(-1,0)]:\n                new_m, new_n = m + move[0], n + move[1]\n                if self._dfs(board,visited, word, new_m, new_n,pos+1):\n                    return True\n            visited[m][n] = False\n        return False\n        visited=[[False]*len(board[0]) for _ in range(len(board))]\n        for m in range(len(board)):\n            for n in range(len(board[0])):\n                if self._dfs(board, visited, word, m, n, 0):\n                    return True\n        return False",
  "Solution_9": "class Solution:\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\n        result = []\n\n        def backtrack(start, current_combination, current_sum):\n            if current_sum == target:\n                result.append(list(current_combination))\n                return\n\n            if current_sum > target:\n                return\n\n            for i in range(start, len(candidates)):\n                current_combination.append(candidates[i])\n                backtrack(i, current_combination, current_sum + candidates[i])\n                current_combination.pop()\n\n        \n        backtrack(0,[],0)\n        return result",
  "Solution_10": "class Solution:\n    def mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:\n        heap = []\n        \n        for l in lists:\n            current = l\n\n            while current:\n                heappush(heap, current.val)\n                current = current.next\n                \n        if len(heap) < 1:\n            return\n        \n        new_root = ListNode(heappop(heap))\n        current = new_root\n\n        while len(heap) > 0:\n            new_node = ListNode(heappop(heap))\n            current.next = new_node\n            current = new_node\n\n        return new_root",
  "Solution_11": "class Solution:\n    def search(self, nums: List[int], target: int) -> int:\n        left, right = 0, len(nums) - 1\n        while left <= right:\n            mid = (left + right) // 2\n            if nums[mid] == target:\n                return mid\n            \n            # left sorted\n            if nums[left] <= nums[mid]:\n                if target < nums[left] or target > nums[mid]:\n                    left = mid + 1\n                else:\n                    right = mid -1\n            else:\n                if target < nums[mid] or target > nums[right]:\n                    right = mid -1\n                else:\n                    left = mid + 1\n        return -1",
  "Solution_12": "import heapq\n\nclass Solution:\n    def findKthLargest(self, nums: list[int], k: int) -> int:\n        max_heap = []\n        for num in nums:\n            heapq.heappush(max_heap , num)\n        while len(max_heap) > k:\n            heapq.heappop(max_heap)\n        return max_heap[0]",
  "Solution_13": "class Solution:\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\n        if len(nums1) > len(nums2):\n            nums1, nums2 = nums2, nums1\n        N1, N2 = len(nums1), len(nums2)\n        l, r = 0, N1\n        while True:\n            m1 = (l + r) // 2\n            m2 = (N1 + N2 + 1) // 2 - m1\n            left1 = nums1[m1 - 1] if 0 <= m1 - 1 < N1 else -math.inf\n            left2 = nums2[m2 - 1] if 0 <= m2 - 1 < N2 else -math.inf\n            right1 = nums1[m1] if 0 <= m1 < N1 else math.inf\n            right2 = nums2[m2] if 0 <= m2 < N2 else math.inf\n\n            # 1 4 5 7\n            # 3 4 5 7 8 9\n            #\n            # m1=1\n            # m2=4\n            if max(left1, left2) <= min(right1, right2):\n                if (N1 + N2) % 2 == 0:\n                    return (max(left1, left2) + min(right1, right2)) / 2\n                else:\n                    return max(left1, left2)\n            elif left1 <= right2:\n                l = m1 + 1\n            else:\n                r = m1 - 1",
  "Solution_14": "class Solution:\n    def numIslands(self, grid: List[List[str]]) -> int:\n        \n        seen = [[0 for j in i] for i in grid]\n        islands = 0\n        for k, row in enumerate(grid):\n            for l, val in enumerate(row):\n                if not seen[k][l] and grid[k][l]==\"1\":\n                    # print(k, l)\n                    islands += 1\n                    stack = [(k, l)]\n                    seen[k][l] = 1\n                    while stack:    \n                        i, j = stack.pop()\n\n                        if not i-1<0 and grid[i-1][j]==\"1\" and not seen[i-1][j]:\n                            stack.append((i-1, j))\n                            seen[i-1][j] = 1\n                        if i+1<len(grid) and grid[i+1][j]==\"1\" and not seen[i+1][j]:\n                            stack.append((i+1, j))\n                            seen[i+1][j] = 1\n                        if not j-1<0 and grid[i][j-1]==\"1\" and not seen[i][j-1]:\n                            stack.append((i, j-1))\n                            seen[i][j-1] = 1\n                        if j+1<len(grid[0]) and grid[i][j+1]==\"1\" and not seen[i][j+1]:\n                            stack.append((i, j+1))\n                            seen[i][j+1] = 1\n                        # print(seen)\n                        # print(stack)\n        return islands",
  "Solution_15": "from typing import Optional\nclass Solution:\n    def cloneGraph(self, node: Optional['Node']) -> Optional['Node']:\n        \n        if not node:\n            return None\n        old_to_new = {}\n        old_to_new[node] = Node(node.val)\n        q = deque([node])\n        while q:\n            qlen = len(q)\n            for _ in range(qlen):\n                curr_node = q.popleft()\n                for neighbor in curr_node.neighbors:\n                    if neighbor not in old_to_new:\n                        old_to_new[neighbor] = Node(neighbor.val)\n                        q.append(neighbor)\n                    old_to_new[curr_node].neighbors.append(old_to_new[neighbor])\n        return old_to_new[node]",
  "Solution_16": "from itertools import product\n\nclass Solution:\n    def longestIncreasingPath(self, matrix: List[List[int]]) -> int:\n        nrows = len(matrix)\n        ncols = len(matrix[0])\n\n        memo = [[1] * ncols for _ in range(nrows)]\n        cells = [(matrix[i][j], i, j) for i, j in product(range(nrows), range(ncols))]\n        cells.sort(key=lambda cell: cell[0])\n\n        for value, x, y in cells:\n            for xx, yy in [(x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1)]:\n                if xx < 0 or xx >= nrows or yy < 0 or yy >= ncols or matrix[xx][yy] <= value:\n                    continue\n\n                memo[xx][yy] = max(memo[xx][yy], memo[x][y] + 1)\n \n        \n        return max(memo[i][j] for i, j in product(range(nrows), range(ncols)))",
  "Solution_17": "from collections import deque\n\n# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nclass Solution:\n    def rightSideView(self, root: Optional[TreeNode]) -> List[int]:\n        # Initialize the array to hold the right side view elements\n        right_side_view = []\n      \n        # If the tree is empty, return the empty list\n        if root is None:\n            return right_side_view\n      \n        # Use deque as a queue to hold the nodes at each level\n        queue = deque([root])\n      \n        # Continue until the queue is empty\n        while queue:\n            # The rightmost element at the current level is visible from the right side\n            right_side_view.append(queue[-1].val)\n          \n            # Iterate over nodes at the current level\n            for _ in range(len(queue)):\n                # Pop the node from the left side of the queue\n                current_node = queue.popleft()\n              \n                # If left child exists, add it to the queue\n                if current_node.left:\n                    queue.append(current_node.left)\n              \n                # If right child exists, add it to the queue\n                if current_node.right:\n                    queue.append(current_node.right)\n                  \n        # Return the list containing the right side view of the tree\n        return right_side_view"
}
